import { AstNode, LangiumDocument, URI } from 'langium';
import * as fsPromises from 'fs/promises';
import * as path from 'node:path';
import { getWorkspaceForDocument } from './tools.js';

/**
 * Represents the generated content for files.
 *
 * The map keys are file paths (relative to the output directory), and the values are objects containing:
 * - `content`: The generated content of the file.
 * - `overwrite`: A flag indicating whether to overwrite existing files.
 * - `documentPath`: The path to the source document from which the file was generated.
 */
export type GeneratedContent = Map<
  string,
  {
    content: string;
    overwrite: boolean;
    documentPath: string;
  }
>;

/**
 * Represents a target output directory for generated files.
 */
export interface GeneratorTarget {
  /** The name of the target. */
  name: string;
  /** Default value for the `overwrite` flag for the target. */
  overwrite: boolean;
}

/**
 * The default target used when no specific target is provided.
 */
export const DEFAULT_TARGET: GeneratorTarget = { name: 'DEFAULT', overwrite: true };

/**
 * Options for creating a file.
 */
export interface CreateFileOptions {
  /**
   * If `true`, existing files on the filesystem will be overwritten with the new content.
   * Value `false` can be used for initial generation of files.
   * Defaults to `true` for the default target.
   * Custom targets have their own default value for the `overwrite` flag.
   */
  overwrite?: boolean;

  /**
   * The output directory target name to use.
   * Defaults to {@link DEFAULT_TARGET}.
   * Different targets can be written to different output directories and can have different default `overwrite` flags.
   */
  target?: string;
}

/**
 * Manages code generation for a specific model.
 *
 * Provides:
 * - Access to the underlying workspace, document, and model.
 * - Methods to collect generated files.
 * - Support for multiple output directories (targets).
 *
 * @typeParam MODEL - The type of the AST node model.
 */
export interface GeneratorManager<MODEL extends AstNode = AstNode> {
  /**
   * Creates a new file with the specified content and options.
   *
   * @param filePath - The file name with an optional relative path, relative to the output directory.
   * @param content - The generated content of the new file.
   * @param options - Optional settings for file generation.
   */
  createFile(filePath: string, content: string, options?: CreateFileOptions): void;

  /**
   * Returns the model associated with the current generator.
   *
   * @returns The model of type `MODEL`.
   */
  getModel(): MODEL;

  /**
   * Returns the associated Langium document, if known.
   *
   * @returns The associated `LangiumDocument`, or `undefined` if not available.
   */
  getDocument(): LangiumDocument<MODEL> | undefined;

  /**
   * Returns the workspace URI corresponding to the Langium document URI.
   *
   * The URI will be selected from a list of known workspace URIs.
   *
   * @returns The workspace `URI` if it could be determined, or `undefined` otherwise.
   */
  getWorkspaceURI(): URI | undefined;

  /**
   * Returns the relative path of the Langium document within the determined workspace.
   * See {@link getWorkspaceURI}.
   * If DSL file is outside of all workspace directories, filename with extension (basename) is returned.
   * `/` is used on all platforms as directory separator.
   *
   * @returns The relative path as a string, if the workspace URI could be determined, filename with extension or `undefined` otherwise.
   */
  getDocumentLocalPath(): string | undefined;
}

/**
 * Manages the collection of generated content for code generation.
 *
 * The `GeneratedContentManager` allows you to:
 * - Collect generated files from multiple models.
 * - Handle multiple targets (output directories) with custom overwrite settings.
 * - Write the collected generated content to the filesystem.
 *
 * @example
 * ```typescript
 * const manager = new GeneratedContentManager(optionalListOfWorkspaceURIs);
 *
 * // Generate content for multiple models
 * generator(manager.generatorManagerFor(model1));
 * generator(manager.generatorManagerFor(model2));
 *
 * // Retrieve the collected content (optional)
 * const content = manager.getGeneratedContent();
 *
 * // Write the generated content to disk
 * await manager.writeToDisk('./generated');
 * ```
 *
 * @example
 * ```typescript
 * function generator(manager: GeneratorManager) {
 *   const model = manager.getModel();
 *   const document = manager.getDocument();
 *   const workspaceURI = manager.getWorkspaceURI();
 *   const localPath = manager.getDocumentLocalPath();
 *
 *   // Generate files
 *   manager.createFile('src-gen/abstract_process.ts', '// Generated by Langium. Do not edit.');
 *   manager.createFile('src/process.ts', '// Initially generated by Langium', { overwrite: false });
 * }
 * ```
 *
 * @see {@link GeneratorManager}
 * @category Generator
 */
export class GeneratedContentManager {
  private readonly generatedContentMap: Map<string, GeneratedContent> = new Map([
    [DEFAULT_TARGET.name, new Map()],
  ]);
  private readonly targetMap: Map<string, GeneratorTarget> = new Map();
  private readonly workspaceURIs?: URI[];

  /**
   * Creates a new instance of `GeneratedContentManager`.
   *
   * @param workspaceDirs - Optional list of workspace directories (as strings or URIs).
   *                        Used to determine the workspace URI for documents.
   */
  constructor(workspaceDirs?: Array<string | URI>) {
    this.workspaceURIs = workspaceDirs?.map((dir) => (typeof dir === 'string' ? URI.parse(dir) : dir));
    this.targetMap.set(DEFAULT_TARGET.name, DEFAULT_TARGET);
  }

  /**
   * Adds a new target to the generator output.
   * The target name must be unique.
   *
   * @param target - The target to add with name and other settings.
   *
   * @throws {Error} If the target has already been added.
   */
  addTarget(target: GeneratorTarget): void {
    if (this.generatedContentMap.has(target.name)) {
      throw new Error(`Target "${target.name}" has already been added`);
    }
    this.generatedContentMap.set(target.name, new Map());
    this.targetMap.set(target.name, target);
  }

  /**
   * Creates a new `GeneratorManager` for the given AST model.
   *
   * @typeParam MODEL - The type of the AST node model.
   * @param model - The AST model for which to create the generator manager.
   *
   * @returns A new instance of `GeneratorManager` associated with the provided model.
   */
  generatorManagerFor<MODEL extends AstNode = AstNode>(model: MODEL): GeneratorManager<MODEL> {
    const documentURI = model.$document?.uri;
    const documentURIString = documentURI?.toString();
    const workspaceURI = getWorkspaceForDocument(documentURI, this.workspaceURIs);
    const workspaceRelativePath = workspaceURI !== undefined && documentURI !== undefined
      ? path.posix.relative(workspaceURI.path, documentURI.path)
      : undefined;
    const relativePath =
      workspaceRelativePath ||
      (documentURIString !== undefined
        ? path.basename(documentURIString)
        : undefined);
    const documentPath = workspaceRelativePath || documentURI?.toString() || 'document URI undefined';
    return {
      createFile: (filePath: string, content: string, options?: CreateFileOptions) => {
        const target = this.#getTarget(options?.target);
        const overwrite = options?.overwrite ?? target.overwrite;
        this.createFile(target.name, filePath, content, overwrite, documentPath);
      },
      getModel: () => model,
      getDocument: () => model.$document as LangiumDocument<MODEL> | undefined,
      getWorkspaceURI: () => workspaceURI,
      getDocumentLocalPath: () => relativePath,
    };
  }

  /**
   * Creates a new file with the given content and metadata.
   *
   * @param targetName - The target name for which the file is generated. Defaults to the default target.
   * @param filePath - The relative path of the file to create.
   * @param content - The content of the file.
   * @param overwrite - Whether to overwrite the file if it already exists.
   * @param documentPath - The path to the source document from which the file was generated.
   *
   * @throws {Error} If a file with the same path and different content or overwrite flag has already been generated.
   */
  createFile(
    targetName: string | undefined,
    filePath: string,
    content: string,
    overwrite: boolean,
    documentPath: string
  ): void {
    const target = this.#getTarget(targetName);
    const generatedContent = this.getGeneratedContent(target.name);
    const existingContent = generatedContent?.get(filePath);
    if (existingContent) {
      if (existingContent.content !== content) {
        throw new Error(
          `Conflict generating file "${filePath}" from "${documentPath}": A file with different content was already generated from "${existingContent.documentPath}".`
        );
      }
      if (existingContent.overwrite !== overwrite) {
        throw new Error(
          `Conflict generating file "${filePath}" from "${documentPath}": A file with different overwrite flag was already generated from "${existingContent.documentPath}".`
        );
      }
      // Allow generating the same file multiple times with the same content and overwrite flag
    } else {
      generatedContent.set(filePath, {
        content,
        overwrite: overwrite,
        documentPath: documentPath,
      });
    }
  }

  /**
   * Return all known targets.
   * @returns An array of all known targets.
   */
  getTargets(): GeneratorTarget[] {
    return Array.from(this.targetMap.values());
  }

  /**
   * Returns the generated content for the provided target or the default target.
   *
   * @param targetName - The target name for which to get the generated content.
   *                     If not provided, the default target is used.
   *
   * @returns A `GeneratedContent` map containing the generated files.
   *
   * @throws {Error} If the specified target is not registered.
   */
  getGeneratedContent(targetName?: string): GeneratedContent {
    return this.generatedContentMap.get(this.#getTarget(targetName).name)!;
  }

  /**
   * Returns the Target object for the provided target name or the default target.
   *
   * @param targetName - The target name for which to get the generated content.
   *                     If not provided, the default target is used.
   *
   * @returns The `GeneratorTarget` object for the specified target.
   *
   * @throws {Error} If the specified target is not registered.
   */
  #getTarget(targetName?: string): GeneratorTarget {
    const resolvedTargetName = (targetName || DEFAULT_TARGET.name);
    if (!this.generatedContentMap.has(resolvedTargetName)) {
      throw new Error(`Target "${resolvedTargetName}" is not registered`);
    }
    return this.targetMap.get(resolvedTargetName)!;
  }

  /**
   * Recursively lists all files in the given directory.
   * 
   * @param dir - The directory to scan for files.
   * @returns A promise resolving to an array of absolute file paths.
   * @private
   */
  private async listAllFiles(dir: string): Promise<string[]> {
    const entries = await fsPromises.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(
      entries.map(async (entry) => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          return this.listAllFiles(fullPath);
        } else if (entry.isFile()) {
          return [fullPath];
        } else {
          return []; // Skip symbolic links, etc.
        }
      })
    );
    return files.flat();
  }

/**
   * Writes the generated content for a target to the file system asynchronously.
   *
   * Existing files are only overwritten if the overwrite flag is set (default behavior).
   * If the file already exists and the content is the same, the file is not overwritten,
   * preserving the timestamp and not triggering file system file change events.
   *
   * Files in the output directory that are not
   * part of the generated content will be deleted after writing.
   *
   * Equivalent to `writeToDisk(outputDir, target, true)`
   *
   * @param outputDir - The output directory where the files will be written.
   * @param target - The target name whose content should be written.
   *                 If not provided, the default target is used.
   * @throws {Error} If an error occurs during file or directory operations.
   */
  async cleanAndWriteToDisk(outputDir: string, target?: string): Promise<void> {
    return this.writeToDisk(outputDir, target, true);
  }

/**
   * Writes the generated content for a target to the file system asynchronously.
   *
   * Existing files are only overwritten if the overwrite flag is set (default behavior).
   * If the file already exists and the content is the same, the file is not overwritten,
   * preserving the timestamp and not triggering file system file change events.
   *
   * @param outputDir - The output directory where the files will be written.
   * @param target - The target name whose content should be written.
   *                 If not provided, the default target is used.
   * @param clean If `true`, files in the output directory that are not
   *              part of the generated content will be deleted after writing.
   *
   * @throws {Error} If an error occurs during file or directory operations.
   */
  async writeToDisk(outputDir: string, target?: string, clean?: boolean): Promise<void> {
    const generatedContent = this.getGeneratedContent(target);

    // Ensure the output directory exists
    try {
      await fsPromises.mkdir(outputDir, { recursive: true });
    } catch (error) {
      console.error(`Error creating directory "${outputDir}": ${(error as Error).message}`);
      throw error;
    }

    // Collect existing files if cleaning is enabled
    let existingFiles: Set<string> | undefined;
    if (clean) {
      try {
        const files = await this.listAllFiles(outputDir);
        existingFiles = new Set(files);
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
          existingFiles = new Set(); // Directory doesn't exist yet
        } else {
          console.error(`Error listing files in "${outputDir}": ${(error as Error).message}`);
          throw error;
        }
      }
    }

    for (const [file, content] of generatedContent) {
      const absoluteFilePath = path.join(outputDir, file);
      const fileDir = path.dirname(absoluteFilePath);

      // Ensure the directory for the file exists
      try {
        await fsPromises.mkdir(fileDir, { recursive: true });
      } catch (error) {
        console.error(`Error creating directory "${fileDir}": ${(error as Error).message}`);
        throw error;
      }

      // If cleaning, check if this generated file exists and remove it from the set
      if (existingFiles) {
        try {
          const realPath = await fsPromises.realpath(absoluteFilePath);
          existingFiles.delete(realPath); // Remove actual OS-reported path
        } catch (error) {
          if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
            console.error(`Error resolving path "${absoluteFilePath}": ${(error as Error).message}`);
            throw error;
          }
          // File doesn't exist yet, will be created below
        }
      }

      let fileExists = false;
      let existingContent = '';

      // Check if the file exists and read its content
      try {
        existingContent = await fsPromises.readFile(absoluteFilePath, 'utf8');
        fileExists = true;
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
          console.error(`Error reading file "${absoluteFilePath}": ${(error as Error).message}`);
          throw error;
        }
        // File does not exist, proceed to write
      }

      // Determine whether to write the file
      if (fileExists && (!content.overwrite || existingContent === content.content)) {
        // Skip writing the file if overwrite is false or content is the same
        continue;
      }

      // Write the file
      try {
        await fsPromises.writeFile(absoluteFilePath, content.content);
      } catch (error) {
        console.error(`Error writing file "${absoluteFilePath}": ${(error as Error).message}`);
        throw error;
      }
    }

    // Clean up files that weren't generated
    if (clean && existingFiles && existingFiles.size > 0) {
      for (const fileToDelete of existingFiles) {
        try {
          await fsPromises.unlink(fileToDelete);
        } catch (error) {
          console.error(`Error deleting file "${fileToDelete}": ${(error as Error).message}`);
          // Log and continue to avoid stopping on single file failure
        }
      }
    }
  }
}
