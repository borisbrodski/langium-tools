import { AstNode, LangiumDocument, URI } from 'langium';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { getWorkspaceForDocument } from './tools.js';

/**
 * Generated content.
 *
 * Map: file path -> file description.
 */
export type GeneratedContent = Map<string, {
  content: string,
  overwrite: boolean,
  documentPath: string
}>;

export interface Target {
  name: string
}

export const DEFAULT_TARGET: Target = { name: "DEFAULT" }

/**
 * Interface for generator manager.
 * 
 * - provides information about underlying workspace, document and model
 * - collects generated files
 * - supports multiple output directories (Xtext outlets)
 */
export interface GeneratorManager<MODEL extends AstNode = AstNode> {

  /**
   * Create new file with relative path and generated content.
   *
   * @param filePath filename with optional relative path, relative to 'generated' directory.
   *                          See <code>GeneratorOutputCollector.writeToDisk(dir)</code>
   * @param content generated content of the new file
   * @param [options] options are:
   *  <code>overwrite</code> - if existing file on the filesystem should be overwritten with the new content.
   *                           Can be used to make initial generation of files.
   *                           Default is <code>true</code> for the default target,
   *                           custom targets have thier own default value for <code>overwrite</code> flag.
   *  <code>target</code>    - target output directory to use.
   *                           Default @{link DEFAULT_TARGET}.
   *                           Different targets can to written to different output directories and can have different default <code>overwrite</code> flag.
   */
  createFile(filePath: string, content: string, options?: { overwrite?: boolean, target?: Target }): void;

  /**
   * Return model ({AstNode} of generic type MODEL).
   * @return {MODEL} model for current generator.
   */
  getModel(): MODEL;

  /**
   * Return associated document.
   *
   * @return {LangiumDocument} associated langium document, if known.
   */
  getDocument(): LangiumDocument<MODEL> | undefined;

  /**
   * Return workspace URI corresponding to the langium document URI.
   * The URI will be selected from a list of known workspace URIs.
   * @return {URI} workspace URI if could be determined
   */
  getWorkspaceURI(): URI | undefined;

  /**
   * Return relative path of the langium document within the determined workspace.
   * See <code>getWorkspaceURI()</code>.
   *
   * @return {string} relative path, if workspace URI could be determined.
   */
  getDocumentLocalPath(): string | undefined;
}

/**
 * Collects generated content.
 *
 * Usage:
 *
 * ```ts
 * const collector = new GeneratorOutputCollector(optionalsListOfWorkspaceURIs)
 *
 * generator(collector.generatorOutputFor(model1))
 * generator(collector.generatorOutputFor(model2))
 *
 * const content = collector.getGeneratedContent()
 * collector.writeToDisk('./')
 * ```
 *
 * ```ts
 * function generator(output: GeneratorOutput) {
 *   const model = output.getModel()
 *   const document = output.getDocument()
 *   const workspaceURI = output.getWorkspaceURI()
 *   const localPath = output.getDocumentLocalPath()
 *   
 *   output.createFile("src-gen/abstract_process.ts", "// Generated by Langium. Don't edit.")
 *   output.createFile("src/process.ts", "// Initially generated by Langium", false)
 * }
 * ```
 *
 * @see {@link GeneratorManager}
 * @category Generator
 * @since 0.1.0
 */
export class GeneratedContentManager {

  private readonly generatedContent: GeneratedContent = new Map();
  private readonly defaultOverwriteMap: Map<Target, boolean> = new Map();
  private readonly workspaceURIs?: URI[]

  constructor(workspaceDirs?: Array<string | URI>) {
    this.workspaceURIs = workspaceDirs?.map(dir => typeof dir === 'string' ? URI.parse(dir) : dir);
    this.defaultOverwriteMap.set(DEFAULT_TARGET, true)
  }

  addTarget(target: Target, defaultOverwrite: boolean) {

  }

  /**
   * Creates a new instance of GeneratorOutput for the given AST model.
   *
   * @param model - The AST model
   * @returns A new instance of GeneratorOutput.
   * @since 0.1.0
   */
  generatorManagerFor<MODEL extends AstNode = AstNode>(model: MODEL): GeneratorManager<MODEL> {
    const documentURI = model.$document?.uri
    const workspaceURI = getWorkspaceForDocument(documentURI, this.workspaceURIs)
    const relativePath = workspaceURI !== undefined ? documentURI?.toString().slice(workspaceURI.toString().length) : undefined
    const documentPath = relativePath || documentURI?.toString() || 'document URI undefined'
    return {
      createFile: (filePath: string, content: string, overwrite: boolean = true) => {
        this.createFile(filePath, content, overwrite, documentPath);
      },
      getModel: () => model,
      getDocument: () => model.$document as LangiumDocument<MODEL> | undefined,
      getWorkspaceURI: () => workspaceURI,
      getDocumentLocalPath: () => relativePath
    };
  }

  /**
   * Creates a new file with the given content and DSL file identified by the provided workspace path..
   *
   * @param filePath - The path of the file to create.
   * @param content - The content of the file.
   * @param overwrite - Whether to overwrite the file if it already exists.
   * @param documentPath - The relative to workspace or absolute path to the langium document, source of the generated file.
   *                       Used e.g. to reference to the langium document in the possible error messages.
   */
  createFile(filePath: string, content: string, overwrite: boolean, documentPath: string): void {
    const existingContent = this.generatedContent.get(filePath);
    if (existingContent) {
      if (existingContent.content != content)
        throw new Error(`ERROR generating ${documentPath} -> ${filePath}: File with different content was already generated from ${existingContent.documentPath}`);
      if (existingContent.overwrite !== overwrite)
        throw new Error(`ERROR generating ${documentPath} -> ${filePath}: File with different overwrite flag was already generated from ${existingContent.documentPath}`);
      // Allow generating the same file multiple times with the same content and overwrite flag
    } else {
      this.generatedContent.set(filePath, {
        content,
        overwrite: overwrite,
        documentPath: documentPath
      });
    }
  }

  /**
   * Returns the generated content.
   *
   * @returns The generated content.
   * @since 0.1.0
   */
  getGeneratedContent(): GeneratedContent {
    return this.generatedContent;
  }

  /**
   * Writes the generated content (for a target) to the file system.
   *
   * Existing files are only overwritten if the overwrite flag is set (default behavior).
   * If the file already exists and the content is the same, the file is not overwritten
   * preveserving the timestamp and not triggering file system file change events.
   *
   * @param outputDir - The output directory.
   * @param [target] - Content to write. {@link DEFAULT_TARGET} will be used if not provided.
   * @since 0.1.0
   */
  writeToDisk(outputDir: string, target?: Target) {
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    this.generatedContent.forEach((content, file) => {
      const absoluteFilePath = path.join(outputDir, file);
      const filePath = path.dirname(absoluteFilePath);
      if (!fs.existsSync(filePath)) {
        fs.mkdirSync(filePath, { recursive: true });
      } else if (fs.existsSync(absoluteFilePath)) {
        if (!content.overwrite) {
          return;
        }
        const existingContent = fs.readFileSync(absoluteFilePath);
        if (existingContent.toString() === content.content) {
          return;
        }
      }
      fs.writeFileSync(absoluteFilePath, content.content);
    });
  }
}
